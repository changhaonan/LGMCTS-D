from __future__ import annotations
"""
New version of region sampler, remove direction related things.
Instead of using mask, using center + size representation.
Sampling using corrosion now & probability summary now.
"""

""" Region sampler for notion """
from scipy.spatial import ConvexHull
from dataclasses import dataclass
from lgmcts.algorithm.region import Region, Region2D
import numpy as np
from typing import Tuple, List, Union, Dict
from enum import Enum
import cv2
import copy
import open3d as o3d
import colorsys


class SampleStatus(Enum):
    """Sample status"""

    SUCCESS = 0  # success
    REGION_SMALL = 1  # region is too small
    COLLISION = 2  # collision
    UNKNOWN = 3  # unknown, placeholder


## Utils
def improve_saturation(color_rgb: Tuple[int, int, int], percent: float) -> Tuple[int, int, int]:
    color_hsv = colorsys.rgb_to_hsv(*color_rgb)  # Convert RGB to HSV
    # Increase saturation by 50%
    new_saturation = color_hsv[1] * (1.0 + percent)
    # Ensure saturation value is within valid range of [0, 1]
    new_saturation = max(0, min(1, new_saturation))
    # Create new color in HSV format with increased saturation
    new_color_hsv = (color_hsv[0], new_saturation, color_hsv[2])
    # Convert new color from HSV to RGB format
    new_color_rgb = colorsys.hsv_to_rgb(*new_color_hsv)
    return new_color_rgb


@dataclass
class ObjectData:
    """Object data
    name: name of object
    pos: position in region2D
    pos_offset: in region2D, we use center of 2D mask to represent obj position,
        this can generate a offset compared with real position projection. This
        offset compares the desired origin of object and center of mask in 3d space.
    mask: mask of object, generated by projecting points to 2D plane. Padded to
        have an odd size.
    height: height of object.
    points: points of object.
    color: color of object.
    """

    name: str
    pos: np.ndarray  # center position
    pos_offset: np.ndarray
    mask: np.ndarray  # mask
    height: float  # height
    points: np.ndarray
    color: Tuple[int, int, int]


class Region2DSampler(Region2D):
    """Region2D sampler"""

    def __init__(
        self,
        resolution: float,
        grid_size: Union[List[int], None] = None,
        world2region: np.ndarray = np.eye(4, dtype=np.float32),
        name: str = "region",
        **kwargs,
    ):
        super().__init__(resolution, grid_size, world2region, name, **kwargs)
        self.occupancy_map = None
        self.objects : Dict[int, ObjectData] = {}
        self._spatial_feasibility = True

    def reset(self):
        """Reset sampler"""
        self.objects = {}

    ## Utility functions
    
    def _region2world(self, pos: np.ndarray):
        """Transform position from region to world"""
        if pos.shape == (3,):
            pos = pos[None, :]
        # use homogeneous coordinate
        if pos.shape[-1] != 3:
            pos = pos[:, :3]
        # there will be a small error in the position
        pos = (pos[:, :3] * self.resolution).astype(np.float32)
        pos = np.hstack((pos, np.ones((pos.shape[0], 1))))
        pos = (np.matmul(np.linalg.inv(self.world2region), pos.T)).T
        return pos[:, :3].squeeze()

    def _world2region(self, pos: np.ndarray):
        """Transform position from world to region"""
        # append dim
        if pos.shape == (3,):
            pos = pos[None, :]
        # use homogeneous coordinate
        if pos.shape[-1] == 3:
            # pos is of shape (N, 3,)
            pos = np.hstack((pos, np.ones((pos.shape[0], 1))))
        elif pos.shape[-1] != 4:
            raise ValueError("pos'shape should be 3 or 4")
        pos = (self.world2region @ pos.T).T
        pos = (pos[:, :3] / self.resolution).astype(np.int32)
        return pos.squeeze()

    ## API

    def add_object(
        self,
        obj_id: int,
        points: np.ndarray,
        pos_ref: Union[None, np.ndarray] = None,
        color=(127, 127, 127),
    ):
        """Add object to scene, create mask from points"""
        assert points is not None, "points should not be None"
        if pos_ref is None:
            pos_ref = np.mean(points, axis=0)  # the ref position will be at center
        # project points to region plane
        points_region = self._world2region(points)
        points_convex_hull = ConvexHull(points_region[:, :2])
        lb_region = np.array(
            [points_region[:, 0].min(), points_region[:, 1].min(), points_region[:, 2].min()]
        )  # lb, lower bottom
        mask_width = points_region[:, 0].max() - points_region[:, 0].min() + 1
        mask_height = points_region[:, 1].max() - points_region[:, 1].min() + 1
        # pad size to odd
        if mask_width % 2 == 0:
            mask_width += 1
        if mask_height % 2 == 0:
            mask_height += 1
        mask = np.zeros((mask_width, mask_height), dtype=np.uint8)
        cv2.fillConvexPoly(
            mask,
            (points_convex_hull.points[points_convex_hull.vertices]).astype(np.int32)
            - lb_region[:2],
            1,
        )
        height = points_region[:, 2].max() - points_region[:, 2].min()
        # compute offset compared with pos_ref (reference position)
        mask_center = np.array([mask.shape[0] // 2, mask.shape[1] // 2, 0]) + lb_region
        mask_center_world = self._region2world(mask_center)
        pos_offset = mask_center_world - pos_ref
        self.objects[obj_id] = ObjectData(name=f"obj_{obj_id}", pos=mask_center, mask=mask, height=height, color=color, points=points, pos_offset=pos_offset)

    def remove_object(self, obj_id: int) -> None:
        """Remove object from scene"""
        # check if object is in scene
        if obj_id in self.objects:
            self.objects.pop(obj_id)
        else:
            print("Object not found")

    def get_object_pose(self, obj_id: int) -> np.ndarray:
        """Get object position"""
        if obj_id in self.objects:
            mask_center_world = self._region2world(self.objects[obj_id].pos)
            pos_ref_world = mask_center_world - self.objects[obj_id].pos_offset
            return pos_ref_world
        else:
            raise ValueError("Object not found")

    def get_object_poses(self) -> Dict[str, np.ndarray]:
        """Get object dict"""
        obj_poses = {}
        for obj_id in self.objects:
            obj_poses[obj_id] = self.get_object_pose(obj_id)
        return obj_poses

    def set_object_pose(
        self, obj_id: int, obj_pos: np.ndarray, enable_vis: bool = False
    ) -> None:
        """Update object in scene"""
        assert obj_id in self.objects, "Object not found"
        mask_center_world = obj_pos + self.objects[obj_id].pos_offset
        if obj_id in self.objects:
            self.objects[obj_id].pos = self._world2region(mask_center_world)
            if enable_vis:
                self.visualize()

    def set_object_poses(
        self, obj_states: Dict[int, np.ndarray], enable_vis: bool = False
    ) -> None:
        """Update all fg objects in scene"""
        for obj_id, obj_pose in obj_states.items():
            self.set_object_pose(obj_id, obj_pose, enable_vis)

    def crop_to(self, bbox: Tuple[int]):
        """Adapt the size of region"""
        min_x, max_x, min_y, max_y = super().crop_to(bbox)
        # update pose shift
        for obj_name, (pos, mask, color, bbox, offset) in self.objects.items():
            self.objects[obj_name] = (
                pos - np.array([min_x, min_y, 0]),
                mask,
                color,
                bbox - np.array([min_x, min_y, 0]),
                offset,
            )

    ## Sample related
    def _put_mask(
        self,
        mask: np.ndarray,
        pos: np.ndarray,
        occupancy_map: np.ndarray,
        **kwargs,
    ) -> bool:
        """Put mask to the occupancy grid, pos is at left bottom corner of mask"""
        mask_x = mask.shape[0]
        mask_y = mask.shape[1]
        mask_half_x = (mask_x - 1) // 2
        mask_half_y = (mask_y - 1) // 2

        # put mask
        value = kwargs.get("value", 1.0)
        # compute the mask remaining in the region
        mask_min_x = max(0, mask_half_x - pos[0])
        mask_max_x = min(mask_x, self.grid_size[0] - pos[0] + mask_half_x)
        mask_min_y = max(0, mask_half_y - pos[1])
        mask_max_y = min(mask_y, self.grid_size[1] - pos[1] + mask_half_y)
        mask_in_region = mask[mask_min_x:mask_max_x, mask_min_y:mask_max_y]

        if len(occupancy_map.shape) == 2:
            occupancy_map[
                pos[0] - mask_half_x + mask_min_x : pos[0] - mask_half_x + mask_max_x,
                pos[1] - mask_half_y + mask_min_y : pos[1] - mask_half_y + mask_max_y,
            ][mask_in_region == 1] = value
        elif len(occupancy_map.shape) == 3:
            occupancy_map[
                pos[0] - mask_half_x + mask_min_x : pos[0] - mask_half_x + mask_max_x,
                pos[1] - mask_half_y + mask_min_y : pos[1] - mask_half_y + mask_max_y,
                :,
            ][mask_in_region == 1] = value

    def get_occupancy(self, obj_list: list[int] | None = None) -> bool:
        """Update occupancy grid occupied by obj_list"""
        occupancy_map = np.ones((self.grid_size[0], self.grid_size[1]), dtype=np.float32)
        # objects
        if obj_list is None:
            obj_list = list(self.objects.keys())
        for obj_id, obj_data in self.objects.items():
            if obj_id in obj_list:
                self._put_mask(
                    mask=obj_data.mask,
                    pos=obj_data.pos,
                    occupancy_map=occupancy_map,
                    value=0.0,
                )
        return occupancy_map

    def get_free_space(self, obj_id: int) -> np.ndarray:
        """Get the free space of the object using cv2.erosion"""
        obj = self.objects[obj_id]
        mask = obj.mask
        obj_list = [id for id in self.objects if id != obj_id]
        occupancy_map = self.get_occupancy(obj_list)
        # get free space
        free_space = cv2.erode(occupancy_map, mask, iterations=1)
        return free_space

    # Sampling related methods
    def sample(
        self, obj_name: str, num_sample: int, **kwargs
    ) -> Tuple[List[np.ndarray], SampleStatus, Dict[str, float]]:
        """General sampling method"""
        # init
        collision_info = {}

        # sample
        sample_type = kwargs.get("sample_type", "uniform")
        if sample_type == "uniform":
            sample_poses, samples_status = self._sample_uniform(obj_name, num_sample, **kwargs)
        else:
            print(Warning(f"Sample type {sample_type} not supported!"))
            return [], SampleStatus.UNKNOWN, collision_info

        if samples_status == SampleStatus.SUCCESS:
            # get feasible pose
            early_stop = kwargs.get("early_stop", False)
            # cache the object
            self.cache(obj_name)
            valid_sample_poses = []
            for i, sample_pose in enumerate(sample_poses):
                collision_list = self.check_collision(obj_name, sample_pose, **kwargs)
                if not collision_list:
                    if early_stop:
                        # compute collision rate
                        collision_info = {k: v / float(i + 1) for k, v in collision_info.items()}
                        collision_info["num_sample"] = i + 1
                        # decache
                        self.decache()
                        return (
                            [self._region2world(sample_pose)],
                            SampleStatus.SUCCESS,
                            collision_info,
                        )
                    else:
                        valid_sample_poses.append(sample_pose)
                else:
                    for collision_obj_name in collision_list:
                        if collision_obj_name in collision_info.keys():
                            collision_info[collision_obj_name] += 1.0
                        else:
                            collision_info[collision_obj_name] = 1.0
            # decache
            self.decache()

            if not valid_sample_poses:
                # compute collision rate
                collision_info["num_sample"] = len(sample_poses)
                collision_info = {
                    k: v / float(len(sample_poses)) for k, v in collision_info.items()
                }
                return [], SampleStatus.COLLISION, collision_info
            else:
                # transfer to world space
                valid_sample_poses = [self._region2world(pos) for pos in valid_sample_poses]
                return valid_sample_poses, SampleStatus.SUCCESS, collision_info
        else:
            return [], samples_status, collision_info

    def _sample_uniform(
        self, obj_name: str, num_sample: int, **kwargs
    ) -> Tuple[List[np.ndarray], SampleStatus]:
        """Sample a feasible pose uniformly"""
        # sample
        (obj_pos, obj_mask, obj_color, obj_points, obj_offset) = self.objects[obj_name]
        obj_size_x = obj_mask.shape[0]
        obj_size_y = obj_mask.shape[1]
        num_grid_x = self.grid_size[0] - obj_size_x
        num_grid_y = self.grid_size[1] - obj_size_y
        if num_grid_x <= 0 or num_grid_y <= 0:
            return [], SampleStatus.REGION_SMALL
        # decide the num_sample_xy
        sample_poses = []
        if num_sample > num_grid_x * num_grid_y:
            # sample all the grid
            for i in range(num_grid_x):
                for j in range(num_grid_y):
                    sample_poses.append(np.array([i, j, obj_pos[2]]))
        else:
            for i in range(num_sample):
                sample_poses.append(
                    np.array(
                        [
                            np.random.randint(0, num_grid_x),
                            np.random.randint(0, num_grid_y),
                            obj_pos[2],
                        ]
                    )
                )
        return sample_poses, SampleStatus.SUCCESS

    # interface related methods
    def sample_once(
        self,
        obj_name: str,
        direction: Union[Direction, None],
        origin_name: Union[str, None],
        **kwargs,
    ) -> Tuple[Union[np.ndarray, None], SampleStatus, Dict[str, float]]:
        """Sample a feasible pose once"""
        limit_sample = kwargs.get("limit_sample", 100)  # limit the number of sampling
        # get subregion
        if origin_name is None:
            origin_shift = None
        else:
            # TODO: Further check this part
            if origin_name in self.objects:
                # origin should be the center of origin name
                origin = self.objects[origin_name][0]
                mask = self.objects[origin_name][1]
                origin_shift = np.zeros(2)
                origin_shift[0] = origin[0] + mask.shape[0] / 2
                origin_shift[1] = origin[1] + mask.shape[1] / 2
            else:
                raise ValueError("Origin object not found!")
        subregion = self.sub_region(direction, origin_shift)
        # sample
        kwargs["early_stop"] = True
        sample_poses, sample_status, collision_info = subregion.sample(
            obj_name, limit_sample, **kwargs
        )

        if len(sample_poses) == 0:
            return None, sample_status, collision_info
        else:
            return sample_poses[0], sample_status, collision_info

    # create method
    def create(self, method: str, **kwargs):
        """Create region from different methods"""
        if method == "instances":
            self.create_from_instances(**kwargs)
        else:
            super().create(method, **kwargs)

    def create_from_instances(
        self,
        color_image: np.ndarray,
        depth_image: np.ndarray,
        cam2world: np.ndarray,
        intrinsic: np.ndarray,
        instances_pcd: List[o3d.geometry.PointCloud],
        instances_name: List[str],
        **kwargs,
    ):
        """Create region from instances"""
        self.create_from_image(
            color_image=color_image,
            depth_image=depth_image,
            cam2world=cam2world,
            intrinsic=intrinsic,
            require_draw=False,
        )
        for pcd, name in zip(instances_pcd, instances_name):
            obj_color = np.array(pcd.colors).mean(axis=0)
            obj_color = improve_saturation(color_rgb=obj_color, percent=0.5)
            obj_color = (obj_color[0] * 255.0, obj_color[1] * 255.0, obj_color[2] * 255.0)
            # obj pcd
            obj_points = np.array(pcd.points)
            # obj_color = (obj_color[2], obj_color[1], obj_color[0])
            self.add_object(obj_name=name, points=obj_points, color=obj_color)

    # Debug related methods
    def visualize(self, **kwargs):
        """Visualize the occupancy grid"""
        # visualize
        img = np.zeros((self.grid_size[0], self.grid_size[1], 3), dtype=np.uint8)
        # draw region
        region_color = (0, 0, 0)  # White color for region
        img[self.region_map == 0] = region_color

        # draw the objects
        for obj_id, obj_data in self.objects.items():
            obj_color_np = np.array(obj_data.color)
            self._put_mask(
                mask=obj_data.mask,
                pos=obj_data.pos,
                offset=None,
                occupancy_map=img,
                value=obj_color_np,
            )

        # resize the image
        scale_factor = int(500 / self.grid_size[1])
        img_resized = cv2.resize(
            img,
            (img.shape[1] * scale_factor, img.shape[0] * scale_factor),
            interpolation=cv2.INTER_NEAREST,
        )

        show_grid = kwargs.get("show_grid", False)
        if show_grid:
            grid_color = (255, 255, 255, 125)  # White color for grid, 125 for transparency
            for i in range(0, img_resized.shape[0], scale_factor):
                cv2.line(img_resized, (0, i), (img_resized.shape[1], i), grid_color, 1)
            for j in range(0, img_resized.shape[1], scale_factor):
                cv2.line(img_resized, (j, 0), (j, img_resized.shape[0]), grid_color, 1)

        # cibverted to BGR
        # img_resized = cv2.cvtColor(img_resized, cv2.COLOR_RGB2BGR)
        # flip
        # img_resized = np.flipud(img_resized)
        img_resized = np.transpose(img_resized, (1, 0, 2))
        img_resized = np.flipud(img_resized)
        cv2.imshow("Occupancy Grid with Grid Lines", img_resized)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

    def visualize_3d(self):
        """Visualize the region and obj bbox in 3D"""
        vis_list = [self.bbox()]
        if self.region_pcd is not None:
            vis_list.append(self.region_pcd)
        # get obj bbox
        for obj_name, (
            obj_pos,
            obj_mask,
            obj_color,
            obj_points,
            obj_offset,
        ) in self.objects.items():
            o3d_color = (obj_color[0] / 255.0, obj_color[1] / 255.0, obj_color[2] / 255.0)
            bbox = o3d.geometry.AxisAlignedBoundingBox.create_from_points(
                o3d.utility.Vector3dVector(obj_points)
            )
            bbox.color = o3d_color
            pcd = o3d.geometry.PointCloud(o3d.utility.Vector3dVector(obj_points))
            pcd.paint_uniform_color(o3d_color)
            vis_list.append(bbox)
            vis_list.append(pcd)

        o3d.visualization.draw_geometries(vis_list)


if __name__ == "__main__":
    ## Create a test scene using open3d
    # add a plane
    plane = o3d.geometry.TriangleMesh.create_box(width=1.0, height=1.0, depth=0.01)
    # add a sphere
    sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.1)
    sphere.paint_uniform_color([1.0, 0.0, 0.0])
    # add a box
    box = o3d.geometry.TriangleMesh.create_box(width=0.1, height=0.1, depth=0.1)
    box.paint_uniform_color([0.0, 1.0, 0.0])
    # add a cylinder
    cylinder = o3d.geometry.TriangleMesh.create_cylinder(radius=0.1, height=0.2)
    cylinder.paint_uniform_color([0.0, 0.0, 1.0])
    
    # prepare objs as points
    sphere_points = np.asarray(sphere.vertices)
    box_points = np.asarray(box.vertices)
    cylinder_points = np.asarray(cylinder.vertices)

    ## Test region2Dsampler
    # Step 1: create the scene
    region2d_sampler = Region2DSampler(resolution=0.01, grid_size=(100, 100))  # the region is (1, 1)
    region2d_sampler.add_object(0, sphere_points, None, (255, 0, 0))
    region2d_sampler.add_object(1, box_points, None, (0, 255, 0))
    region2d_sampler.add_object(2, cylinder_points, None, (0, 0, 255))
    region2d_sampler.set_object_poses(
        {
            0: np.array([0.3, 0.3, 0.0]),
            1: np.array([0.5, 0.5, 0.0]),
            2: np.array([0.8, 0.8, 0.0]),
        }
    )
    region2d_sampler.visualize(show_grid=True)

    # Step 2: test the free space
    for obj_id in region2d_sampler.objects:
        free_space = region2d_sampler.get_free_space(obj_id)
        cv2.imshow("Free Space", free_space)
        cv2.waitKey(0)